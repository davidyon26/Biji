// /* VIM 参考手册 {{{1 */
= VIM 参考手册
David Yon <davidyon@hotmail.com>
v1.0, 2017-08-03
:toc: right
:toclevels: 4
:numbered:
:icons: font
:source-highlighter: highlightjs
:highlightjsdir: highlight
:experimental:
:sectanchors:
:sectnumlevels: 5

// /* 术语 {{{2 */
== 术语

[horizontal]
[[word,word]]word::
    在VIM中, 一个 _word_ 是通常是由字母, 数字或者下划线组成的字符串. _word_ 可
    以由选项 `iskeyword` 进行重新定义, 因此不同的文件类型, _word_ 的定义可能不
    同. 一个空行也被看作一个 _word_.  
[[WORD,WORD]]WORD::
    在VIM中, 一个 _WORD_ 是由空白符(space, Tab, NL)分隔的一串非空白字符.
    _WORD_ 不能被重新定义. 一个空行也被看作一个 _WORD_.
[[sentence,sentence]]sentence::
    在VIM中, _sentence_ 以 `.`, `!` 或者 `?` 结尾, 后面跟着换行符,空格或者Tab
    字符. 在结束符和空白符之间可以包括任何数目的 `)`, `]`, `"` 以及 `'` 字符.
    _paragraph_ 和 _section_ 边界符也是 _sentence_ 的边界符. +
    _sentence_ 不能被重新定义.

// /* 模式（mode）{{{2 */
== 模式（mode）
Vim是基于模式的编辑器，在不同的模式下，相同的输入会存在不同的含义。两个最常用的
模式是常规（Normal）和插入（Insert）模式。在正常模式下，输入的字符代表特定的
命令。在插入模式下输入的字符是要输入的正文内容。 当使用Vim打开文件是，进入的是
常规模式，所有的输入都作为命令处理。

Vim 有6个基本模式, Normal, Visual, Select, Insert, Command-line 以及 Ex 模式. 
下表对这六种模式做基本的介绍.

=== 基本模式

[cols="2m,8a"]
|===
| 模式 | 简介

| 常规 (Nomral)
| 在常规模式下, 可以输入所有常规的编辑命令. 这种模式也被成为命令模式 (command)
  模式. 除非在配置文件中设置了 insertmode 模式选项, 否则打开 Vim 后, Vim 就是
  处于这种模式.

| 可视 (Visual)
| 它类似于常规模式, 但是在这种模式下主要是使用移动命令来选择正文, 并且被选择的
  正文被高亮显示. 后续的在常规模式下的非移动命令应用于被选择的正文, 比如删除.
  如果 `showmode` 选项被打开, 在屏幕的底部会显示 "-- VISUAL --".

| 选择 (Select)
| 它类似于 MS-Windows 的选择模式. 在选择模式下, 如果输入一个可打印字符, 并选择
  的正文将会被删除, 并进入插入模式. 如果 `showmode` 选项被打开, 在屏幕的底部会
  显示 "-- SELECT --".

| 插入 (Insert)
| 在插入模式下, 你可以输入你想输入的正文, 这些正文被插入到缓冲区中. 如果 `showmode` 
  选项被打开, 在屏幕的底部会显示 "-- INSERT --".

| 命令行 (Command-line)
| 在命令行模式下(也成为Cmdline)模式下, 你可以在窗口的底部输入一行正文. 这种模
  式主要用于 Ex 命令 `:` , 模式搜索命令 `?` 和 `/` , 以及过滤命令 `!`. 

| Ex
| 类似于命令行模式, 但是在执行一个命令后仍然保持在 Ex 模式下. 在 Ex 模式下, 编
  辑命令行不太方便.
|===

=== 附加模式
在基本模式的基础上，Vim 支持6种附加的模式。我们可以将其看作是基本模式的变种。

[cols="2m,8a"]
|===
| 模式 | 简介

| 操作符延迟 (operator-pending)
| 这种模式类似于常规模式, 但是在敲入操作符(operator)命令后, Vim将等待输入动作(motion)命
  令部分用于选择操作符所应用到的正文.

| 替换 (Replace)
| 这个模式是一种特殊的插入模式. 在这种模式下, 如果光标处存在字符,那么新输入的
  字符将替代那个字符. 如果 `showmode` 选项被打开, 在屏幕的底部会显示 "--
  REPLACE --"

| 虚拟替换 (Virtual Replace)
| 虚拟替换模式类似于替换模式. 但是在这个模式下替换的不是文件中的字符, 而是替换
  屏幕的空间, 使得文件中的其它字符不会出现移动. 这种模式特别适合以Tab作为分割
  分隔符表文件. 如果 `showmode` 选项打开, 在屏幕的底部会显示 "-- VREPLACE --".

| 插入常规 (Insert Normal)
| 这种模式类似于插入常规模式, 但是在执行一个命令后, Vim 返回插入模式. 如果
  `showmode` 打开, 在窗口的底部会显示 "-- (insert) --"

| 插入可视 (Insert Visual)
| 在插入模式下开始进行可视选择时进入这种模式, 比如使用CTRL-O, 然后使用v, V 或
  者 CTRL-V. 当可视选择后, Vim返回插入模式. 这种模式在窗口的底部显示 "--
  (insert) VISUAL --"

| 插入选择 (Insert Select)
| 在插入模式下开始选择模式时进入这种模式. 比如拖动鼠标或者 <S-Right>. 当选择摸
  模式结束后, Vim返回到插入状态. 这种模式在窗口的底部显示 "-- (insert) SELECT
  --"
|===

=== 模式间的切换
我们经常会在各种模式之间进行切换，如果你不知道你正处于何种模式，你总是可以通过
按两次 kbd:[ESC] 键返回到常规模式. 但是在 `Ex` 模式下必须使用 ":visual" 返回到
常规模式.

下表列举了各模式之间切换的方法.

[cols="^m,^m,^m,^m,^m,^m,^m,^m"]
|===
.2+| From mode 
7+| To mode
          | Normal | Visual | Select | Insert | Replace | Cmd-line | Ex

| Normal  |        | v V ^V | <4>    | <1>    | R gR    | : / ? !  | Q
| Visual  | <2>    |        | ^G     | c C    | --      | :        | --
| Select  | <5>    | ^O ^G  |        | <6>    | --      | --       | --
| Insert  | <Esc>  | --     | --     |        | <Insert>| --       | --
| Replace | <Esc>  | --     | --     |<Insert>|         | --       | --
| cmdline | <3>    | --     | --     | :start | --      |          | --
| Ex      | :vi    | --     | --     | --     | --      | --       | 
|===

说明:

- --  表示不可能的切换
- 关于数字的说明
. 从常规模式切换到插入模式使用命令: `i`, `I`, `a`, `A`, `o`, `O`,
   `c`, `C`, `s`, `S` 
. 从可视模式切换到常规模式使用非移动命令, 这将导致这个命令执行. 或者通过输入字
  字符 <Esc> "v", "V" 或者 "CTRL-V"
. 从命令行模式到常规模式使用下面的方式:
    ** 敲回车换行 <CR> 或 <NL>, 这将导致输入的命令执行.
    ** 删除整行(例如使用 CTRL-U)后,最后敲入<BS>
    ** 敲 `CTRL-C` 或者 `<Esc>` , 这将不执行输入的命令而退出命令行模式. 如果
    `<Esc>` 作为 `wildchar` 选项的字符, 第一次敲 `<Esc>` 可能会开始命令自动
    完成. 这种情况下, 再次敲 `<Esc>`

=== 可视模式(Visual mode)
可视模式是以高亮的方式显示选择的内容, 然后针对被高亮显示的内容做各种操作. 
使用可视模式包括三个步骤：

i) 使用 v,V or CTRL-V 标记选择的起始位置. 光标所在的字符将作为起始字符.
ii) 移动光标到选择内容的最后一个字符. 这时起始字符和终止字符之间的正文将会被高
   高亮显示.
iii) 敲入可视命令. 这个命名将作用在被高亮标示的选择区域.

我们可以基于字符, 行或者块进行选择. 我们可以通过 `highlight`, `virtualedit` 以
以及 `selection` 选项控制高亮的显示模式, 选择的范围.

==== 进入/退出可视模式

[cols="1m,5a"]
|===
| 方式 | 简介

| [count]v
| 开始基于字符的选择方式.  +
  如果存在 count 并且前面做了基于可视的操作, 那么将选
  择字符或者行的数目是前一次可视操作作用的字符或者行数乘以count. 但是选择的起
  点是当前光标所在的位置. 如果上一次可视操作是基于块的, 那么本次选择也是块, 但
  是块的宽度和高度都乘以count. +
  如果不存在上一次的可视操作,则count个字符被选择. +
  如果当前是基于块或者行的可视模式, 敲入 +v+ 将进入基于字符的可视模式. 如果当前
  已经是基于字符可视模式, 敲入 +v+ 将退出可视模式到常规模式.

| [count]V
| 开始基于行的选择方式. +
  如果使用count且存在上一次可视操作, 那么本次的选择是以当前光标的位置为起点选择
  N行, N=count * <上一次可视操作作用的行数> +
  如果不存在上次可视操作, 则选择count行.  +
  如果当前是基于字符或者基于块的可视选择模式, 敲入 +V+ 将进入基于行的选择方式.
  如果已经是基于行的可视选择方式, 敲入 +V+ 将进入常规模式.

| [count]CTRL-V
| 开始基于块的选择方式 +
  在Windows下, CTRL-V可能被影射为粘贴操作, 这时可以使用CTRL-Q替代. 关于count,
  其作用与v的用法相同. +
  如果当前是基于字符或者行的可视模式, 敲入 +V+ 将进入基于块的可视模式. 如果当
  前已经是基于块的可视模式, 敲入 +CTRL-V+ 将退出可视模式进入常规模式.

| gv
| 开始可视模式, 并且初始的选择区域是上一次的选择区域和选择方式.  +
  如果当前处于可视模式, 则在当前选择的区域和上一次选择的区域间做切换. +
  如果在可视模式执行p或者P操作后执行这个命令, 则原来被粘贴的内容被选择.

| gn
| 与命令 `n` 相似, 基于上一次使用的模式向前搜索, 选择匹配的内容被进入可视模式.
  如果在一个操作处于等待进一步输入状态下执行该操作, 则原来的操作作用在匹配的内
  容上, 比如dgn, 会删除下一次的匹配内容. 
  如果在可视模式下执行该操作,则选择的范围扩展到下一次的匹配.

| gN
| 与 `gn`一样, 只是向后搜索.

| <LeftMouse>
| 设置当前光标的位置. 如果当前是可视模式将退出可视模式. 这个动作只有在 `mouse`
  选项包含 +n+ 或者 +a+ 的时候其作用. 

| <RightMouse>
| 如果当前不是可视模式, 则进入可视模式. 在光标所在位置和鼠标右键点击位置之间的
  正文内容被高亮显示.  +
  如果当前已经是可视模式, 则改变高亮区域的起始点或者终止点. 是改变起始点还是
  终止点取决于两者哪个离鼠标右键的点击点更近. 这个当选项 `mouse` 包括 +n+ 
  或者 +a+ 时有效. +
  *NOTE:*  +
  当选项 `mousemode` 设置成 +popup+ 时, 需要使用 +<S-LeftMouse>+ 而右键.

| <LeftRelease>
| 如果鼠标左键释放的位置不同于它按下的位置, 那么鼠标左键按下位置和释放位置之间
  的内容会被实时高亮显示. 这个当选项 `mouse` 包括 +n+ 或者 +a+ 时有效. +

| <Esc>
| 在可视模式下, 退出可视模式到常规模式

| kbd:[CTRL+C]
| 在可视模式或者插入可视模式下, 停止可视模式.
|===

==== 改变可视区域
使用下面命令可以改变光标在可视区域的位置.

[cols="1m,5a"]
|===
| o
| 光标的位置在起始端和终止端进行切换, 而高亮选择的可视区域不变. 

| O
| 在基于字符或者行的可视模式下与命令 `o` 相同, 但是在基于块的可视模式下, 
  光标将在同行的起始和终止端进行切换. 当用在基于块的可视模式时, 高亮显示区域
  可能会修改.
|===

下面的动作命令用于基于文法的方式改变可视区域

[cols="1m, 5a"]
|===
| 动作  | 简介
| aw    | 选择一个光标所在位置的 <<word,word>> 并且包括分隔符. 
| iw    | 选择一个光标所在位置的 <<word,word>> 并且不包括分隔符. 
| aW    | 选择一个光标所在位置的 <<WORD,WORD>> 并且包括分隔符. 
| iW    | 选择一个光标所在位置的 <<WORD,WORD>> 并且不包括分隔符. 
| as    |
|===

==== 可视操作
对于可视选择区域,可以进行下面的操作:

[cols="1m, 7a"]
|===
| 操作 | 简介

| ~    | 改变大小写
| d    | 删除
| c    | 删除并进入插入模式
| y    | yank
| >    | 向右移动
| <    | 向左移动
| !    | 通过外部命令进行过滤
| =    | 通过 `equalprg` 选项命令进行过滤
| gq   | 将每行重新格式化为 `textwidth` 指定的宽度
|===

==== 移动(motion)命令

// /* 移动光标 {{{2 */
== 移动光标

// /* 左右移动 {{{3 */
=== 左右移动

[cols="2m,1,10"]
|===
| 输入 |  计数 |动作

|  h  | *
| 向左移动N个字符，默认为1。或者 `CTRL-H` `<BS>` `<Left>` 键 

|  l | *
| 向右移动N个字符，默认为1。或者 `<space>` `<Right>` 键 

| 0  |   | 当前行的一个字符。或者 `<Home>` 键
| ^  |   | 当前行的第一个非空字符
| $  | * | 下面N-1行的最后一个字符，默认当前行。或者 `<End>` 键
| g_ | * | 下面N-1行的最后一个非空字符，默认当前行。
| g0 |   | 当前屏幕行的第一个字符，有软换行时不同于0
| g^ |   | 当前屏幕行的第一个非空字符，有软换行时不同于^
| g$ | * | 下面N-1行的最后一个字符，有软换行时不同于$
| gm |   | 当前屏幕行的中间位置。
| \| | * | 第N列，默认为1
|===

关于基于字符查找导致光标移动参见 <<searchChar,查找字符>>  

// /* 上下移动 {{{3 */
=== 上下移动

[cols="2m,1,10"]
|===
| 输入 | 计数 | 动作

|  k  | *
| 向上移动N行，默认为1。或者 `CTRL-P` `<Up>` 键 
|  j | *
| 向下移动N行，默认为1。或者 `CTRL-J` `CTRL-N` `<NL>` `<Down>` 键 

| -  | *
| 向上移动N行，默认为1。光标位于第一个非空字符
| +  | *
| 向下移动N行，默认为1。光标位于第一个非空字符。或者 `CTRL-M` `<CR>`

| _ | * | 向下N-1行的第一个非空字符

| G  | * | 到第N行，默认最后一行第一个非空白字符
| <C-End> | * | 同G，但是默认最后一行的最后一个字符
| :[rang] |   | 跳转到[rang]最后的一行。[rang]可以仅包括一个行号。如“:23” 或
                “:'m”，与G不同的是它不改变jumplist
| gg | * | 到第N行，默认第一行。或 `<C-Home>`

| N% | * | 到文件N%行，N必须提供，否则是%命令

| gk | * | 上移N个屏幕行, 用于存在软换行。或 `g<Up>` 
| gj | * | 下移N个屏幕行，用于存在软换行。或 `g<Down>`

| :[range]go[to] [count] |
| 跳到当前buffer的第{count}字节，默认[count]是1。如果指定了[range], [range]
  最后一个数最为count。换行符是否包括依赖与 `fileformat` 的设置
| [count]go  |
| 同上

|===

// /* 基于屏幕的移动 {{{3 */
=== 基于屏幕的移动

[cols="2m,1,10"]
|===
| 输入 | 计数 | 动作
 
| ctrl-d | *
| 向下滚动半屏, 设置滚动"n"行，并最为新的半屏的默认值

| ctrl-u | *
| 向上滚动半屏, 设置滚动"n"行，并最为新的半屏的默认值

| ctrl-f | *
| 向前滚动N屏 

| ctrl-b | *
| 向后滚动N屏 

| ctrl-y | *
| 向前滚动N行 

| ctrl-e | *
| 向后滚动N行 

| M     |  | 移光标到当前页面中间
| H     |  | 移光标到当前页面的最上部
| L     |  | 移光标到当前页面的最下部
|===

// /*  基于文本的移动 {{{3 */
=== 基于文本的移动
[cols="1s,5"]
|===
| 输入 | 动作

| W +
  w +
  5w +
| 向前移动一个字（空格分隔） +
  向前移动一个字（非字母数字字符分隔） +
  向前移动5个字

| B +
  b +
  5b
| 向后移动一个字（空格分隔） +
  向后移动一个字（非字母数字字符分隔） +
  向后移动5个字

| E +
  e +
  5e
| 向前移动字的尾部（空格分隔） +
  向前移动到字的尾部（非字母数字字符分隔） +
  向前移动到5个字的尾部

| ) | 移动到下一个句的起始位置（以 `.` `,` `?` 或者 `!`做为界定符）
| ( | 移动到当前句的起始位置，如果已经在起始位置，移动到上一句起始位置
     （界定符同上）

| } | 移动到下一段的起始位置（以空白行或者NROFF宏： `.ip` `.lp` `.pp` `.qp` 
      `.P` `.LI` 和 `.bp`最为界定符。(paragraph)
| { | 移动到当前段的起始位置，（界定符同上）

| ]] | 移动光标到下一节(section）起始位置（以nroff宏：`.NH` `.SH` `.H` `.HU` 
       为界定符
| [[ | 移动光标到当前节（section）起始位置（界定符同上）

|===

// /* 多视窗 {{{2 */
[[windows]]
== 多视窗

// /* 基本概念 {{{3 */
=== 基本概念
关于一个被编辑的文件，Vim存在三个概念：buffer, window, tab page。其中

* buffer是这个文件的内存表示，包含文件的正文内容，它唯一对应一个文件。它相当于
  MVC 模型中的Model
* window 是一个buffer在屏幕上的表示（viewport）。一个buffer可以出现在不同的
  window 中。它相当于MVC模型中View
* tab page可以包含多个窗口，Vim可以包含多个tab页。它应该也算是View层次的概念。

我们可以将window看作是平铺式的布局，而tab页是重叠式布局。平铺式是将vim物理窗口
水平或者垂直分割为多个部分，这些部分同时可见。不同部分可以显示相同或者不同
buffer。每个部分我们称其为一个窗口（window），我们管这种方式称其多窗口。重叠方
式是同时只能看到一个显示区域，不同的显示区域重叠在一起，可以选择需要显示那个区
域。我们将这种方式称为 Tab页方式，每个显示区域称为一个tab页，每个tab也又可以分
成多窗口。

// /* 缓冲区（buffer） {{{3 */
[[Buffer]]
=== 缓冲区（buffer）

缓冲区是一个文件被编辑时使用的内存区域，它包括文件的正文内容。这个内容可以被修
改。修改后的内容只用执行写命令后才会被写回到文件。在此之前，文件的内容不变。

在每个Vim会话（session）中，每个缓冲区有唯一的编号和名字，可以使用函数 bufnr()
和 bufname() 获取。 

// /* 缓冲区状态 {{{{4 */
====  缓冲区的状态
缓冲区有三种状态：active, hidden, inactive

[cols="1,1,1,1m,6a"]
|===
| state | displayed in window | loaded | ":buffers" shows | comment

| active | yes | yes | 'a'
| 这个缓冲区在一个窗口中显示。如果已经有一个文件与这个缓冲区对应，那么这个文件
  已经装入了缓冲区。并且缓冲区的内容可能已经修改了，与那个文件的内容不同了。

| hidden | no | yes | 'h'
| 这个缓冲区没有在任何在任何窗口显示。如果已经有一个文件与这个缓冲区对应，那么
  这个文件已经被装入缓冲区。其它方面与active相同，只是不能看到它。

| inactive | no | no | '' ''
| 这个缓冲区没有在任何窗口显示，也不包含任何内容。这块缓冲区的选项会被记录，当
  对应的文件被再次装入时使用。它也可以包含标记，但是不包含任何内容。

|===

// /* 多窗口 {{{3 */
=== 多窗口
vim 支持将一个窗口水平垂直分割成多个窗口，每个窗口可以显示相同或者不同的内容。本节描述关于窗口的分割，光标在多个窗口之间的转换或者控制。

每个窗口有一个唯一的标识符，window ID。这个标识符在这个Vim会话中不会改变。可以
使用函数 win_getid() 或者，每个window也会有一个编号，它的值会随着窗口的打开和
关闭而改变。其函数是 winnr()。

如果一个窗口太小，可以通过设置选项 winheight 或者 winwidth 设置一个窗口的大小。
关于选项参见<<Option,选项>>。

当打开一个新的窗口，读取文件的时候，Buf/Win Enter/Leave autocommand不被执行，
这些autocommand只有当文件的内容已经被装入了才被执行。关于autocommand参见
<<AutoCmd, AutoCmd>>。

// /* 多窗口打开文件 {{{4 */
==== 多窗口打开文件
可以使用-o或者-O选项打开多个文件，每个文件占用一个窗口。前者窗口上下部局，后者
左右部局。如果后面跟着一个数字N，即-oN或者-ON，那么同时打开N个窗口。

[source,bash]
$ vim -o one.txt two.txt three.txt
$ vim -O one.txt two.txt three.txt

// /* 窗口创建与关闭 {{{4 */
==== 窗口创建与关闭

[cols="2m,1,6"]
|===
| 命令 | 计数 | 含义

| CTRL-W s +
  CTRL-W S +
  CTRL-W CTRL-S +
  :split +
  :split _file name_
| *
| 将当前窗口分割成上下两个窗口，光标停留在上面的窗口。默认情况显示相同的内容，
  你可以在两个窗口查看同一个文件不同部分的内容。如果指定计数，比如 `:3split` 
  表示新的窗口占用3行。

| CTRL-W v +
  CTRL-W CTRL-V +
  :vsplit +
  :vsplit _file name_
| *
| 将当前窗口分割成左右两个窗口。如果指定计数，其为新窗口所占的列数

| CTRL-W n +
  CTRL-W CTRL-N +
  :new
| *
| 创建一个新的窗口包含一个新的空文件。

| :vnew +
  :vertical new
| *
| 垂直创建一个新的窗口包含一个新的空文件。 :vertical命令可以用于任何其它分割窗
  口的命令的前面，用于指明垂直分割窗口

| CTRL-W CTRL-^ +
  CTRL-W ^
| *
| 将窗口splite两部分，编辑任意一个。如果存在计数，编辑buffer N。

| CTRL-W q +
  CTRL-W CTRL-Q +
  CTRL-W c +
  :clo[se] +
  :q[uit] +
  ZZ
| *
| 关闭当前窗口。`:close` 与其它两种方式不同在于，它不会在最后一个窗口时退出vim.
  如果指定计数，是退出第n个窗口。n是指定的计数。

| :hid[e] +
  :hid[e] {cmd}
| *
| 推出当前窗口，除非它是Vim的最后一个窗口。如果存在计数，退出编号为计数的窗口
  。除非存在另外一个窗口编辑这个文件，否则这个窗口对应的buffer成为hidden状态。
  选项 bufhidden 决定当一个buffer不在显示在窗口时，如何进行处理。

| CTRL-W o +
  CTRL-W CTRL-O +
  :on[ly][!]
| *
| 关闭当前窗口以外的所有窗口

|===

// /* 窗口创建相关事项 {{{4 */
==== 窗口创建相关事项

===== s前缀
很多编辑另一个文件的命令有相应的变种命令，用来在新窗口编辑这个文件。这个变种
命令有共同的特征是在相应命令前面加上s。例如

[source,vim]
------
:new   --->  :snew
:tag   --->  :stag
:find  --->  :sfind
------

===== CTRL-W
在noremal模式下，如果某些命令打开一个文件，那么在这个命令前增加 `CTRL-W` 将创建
一个新的窗口来打开相应的文件。

比如 `CTRL-^` 用来打开以前编辑的文件，而 `CTRL-W CTRL-^` 将在新的窗口打开以前
的文件。

===== 位置选项
下面的选项可以决定新窗口出现的当前窗口的位置。

[cols="1m,4a"]
|===
| 选项 | 作用

| splitbelow +
  sb
| 开关选项。当打开时，当水平分割一个窗口时新的窗口在当前窗口的下面。默认关闭。

| splitright +
  spr
| 开关选项。当打开时，当垂直分割一个窗口时新的窗口在当前窗口的右面。默认关闭。

| 例子
|
[source,vim]
----------
:set splitbelow
:set nosplitright
----------
|===

[[WindowsModifier]]
===== 位置修饰符
当创建一个新的窗口时，可以在前面增加一个位置修饰符来明确指定新窗口的位置。在
下面的例子中，如果 `cmd` 是一个分割窗口的命令，将按照修饰符指定的方式分割。
其格式为：

[source, vim]
:lefta[bove] {cmd}    当前窗口的左面或者上面 
:abo[veleft] {cmd}    同上 
:rightb[elow] {cmd}   当前窗口的右面或者下面 
:bel[owright] {cmd}   同上 
:to[pleft]    {cmd}   窗口的最上面或者最左面，占用整个vim的宽度或者高度 
:bo[tright]   {cmd}   窗口的最下面或者最右面，占用这个vim的宽度或者高度
:vert[tical]  {cmd}   垂直创建一个窗口

上面的修饰符可以进行组合，用来垂直分割分割窗口，并占用这个vim窗口的高度。例如

[source,vim]
-----
:vertical topleft split tags  <1>
-----
<1> 在vim窗口最左面垂直分割全高度的窗口，并显示tags文件

// /* 窗口间切换 {{{4 */
==== 窗口间切换

[cols="2m,1,6"]
|===
| 命令 | 计数 | 含义

| CTRL-W w +
  CTRL-W CTRL-W
| *
| 多个窗口间的切换，依次遍历所有窗口。如果未加计数，切换到当前窗口的下/右窗口
  如果没有，切换到最上左的窗口。如果存在计数，切换到计数指定编号的窗口。窗口
  的编号从top-left到bottom-right。如果超过窗口数，切换到最后一个。

| CTRL-W W
| *
| 如果没有计数，与CTRL-W w反向。如果存在计数，与CTRL-W w相同。

| CTRL-W h +
  CTRL-W CTRL-H +
  CTRL-W <Left> +
  CTRL-W <BS>
| *
| 切换到左边的窗口1 或者多次

| CTRL-W j +
  CTRL-W CTRL-J +
  CTRL-W <Down>
| *
| 切换到下面的窗口1 或者多次

| CTRL-W k +
  CTRL-W CTRL-K
  CTRL-W <Up>
| *
| 切换到上面的窗口1 或者多次

| CTRL-W l +
  CTRL-W CTRL-L +
  CTRL-W <Right>
| *
| 切换到右边的窗口1 或者多次

| CTRL-W t +
  CTRL-W CTRL-T
|
| 切换到最上左面的窗口

| CTRL-W b +
  CTRL-W CTRL-B
|
| 切换到最下右面的窗口

| CTRL-W p +
  CTRL-W CTRL-P
|
| 切换到以前操作的窗口
|===

// /* 窗口大小 {{{4 */
==== 窗口大小
本节介绍改变窗口大小的命令

[cols="2m,1,6a"]
|===
| 命令 | 计数 | 含义

| kbd:[CTRL+W] kbd:[=]
|
| 让所有的窗口具有相同的高度和宽度。但是当前的窗口使用选项 winheight 和
  winwidth 的值。另外设置 winfixheight 的窗口保持其高度，设置 winfixwidth 的窗
  口保持其宽度。

| CTRL-W *+*  +
  :res[ize] +N 
| *
| 将当前窗口高度增加1或者N行

| CTRL-W - +
  :res[ize] -N
| *
| 将当前窗口高度减少1或者N行

| CTRL-W _ +
  CTRL-W CTRL-_ +
  :res[ize] [N]
| *
| 如果不指定计数，设置当前窗口为最大的高度。如果指定计数，设置当前窗口为指定
  计数值。

| z{nr}<CR>
|
| 设置当前窗口的高度为{nr}

| CTRL-W <
| *
| 当前窗口的宽度减少N列，默认为1

| CTRL-W >
| *
| 当前窗口的宽度增加N列，默认为1

| :vertical res[ize] [N] +
  CTRL-W \|
| *
| 当前窗口的宽度设置成N。默认最大宽度。
|===

如果想使用鼠标，可以使用鼠标改变窗口大小。使用鼠标设置选项 mouse,

[source, vim]
:set mouse=a

可以使用下面的选项控制窗口的大小

[cols="1m,4a,3a"]
|===
| 选项 | 说明 | 范例

| winheight +
  wh
| 一个新窗口期望的最小大小（以行为单位）
|
[source,vim]
-------
set winheight=10
-------
| winminheight +
  wmh
| 一个窗口可缩小的最小的大小(一行为单位）。这个值在减少一个窗口高度的时候被检
  测。不要将这个值设得太大，否则会出现错误。0-3是比较合理的。
|
[source,vim]
-------
set winminheight=10
-------
| winwidth +
  wiw
| 一个窗口期望的最小宽度（以列为单位）
.2+.^|
[source,vim]
------
set winwidth=50
set winminwidth=20
------
| winminwidth +
  wmw
| 一个窗口最小的宽度（以列为单位）。可以设置为0，不要设置为一个大值，否则在切换
  或者新建一个窗口时会出错。0-12是比较合理的。

| equalalways +
  ea
| 自动保持所有的窗口具有相同的大小。下面的 eadirection 选项影响它的行为。
|
[source,vim]
------
set equalalways
set noequalalways
------

| ead[irection]
| 这个选项影响 equalalways 的行为。其可以取下面三个值：
 
* both: 窗口的宽度和高度均受到影响
* ver:  只影响窗口的高度；宽度不受影响
* hor:  只影响窗口的宽度；高度不受影响
|
[source,vim]
------
:set ead?   "查看它的取值
------
|===

// /* 窗口移动 {{{4 */
==== 窗口移动
下面的命令用于移动窗口的位置

[cols="2m,1,5a"]
|===
| 命令 | 计数 | 含义

| kbd:[CTRL+W] kbd:[R] +
  kbd:[CTRL+W] kbd:[CTRL+R]
|
| 向下向右移动窗口，第1个变成第2个，第n个变成第n+1个，最后一个变成第一个。
  光标随着原来的窗口移动。仅仅作用与与当前窗口等长或者等高的窗口。

| kbd:[CTRL+W] kbd:[Shift+R]
|
| 向上向右移动窗口，第2个变成第1个，第n个变成第n-1个，第一个变成最后一个。

| kbd:[CTRL+W] kbd:[X] +
  kbd:[CTRL+W] kbd:[CTRL+X]
| *
| 
* 如果没有计数，当前窗口和下一个窗口交换；如果当前窗口是最后一个窗口，和
  前一个窗口交换；
* 如果存在计数，当前窗口和指定的第N个窗口交换。光标在交换的窗口。当存在水平和
  垂直混合的情况，仅仅和那些与当前窗口等长或者等高的窗口交换。

| CTRL-W K 
| 
| 将当前窗口移动到顶部，并且占用整个vim窗口的宽度。窗口的位置类似于位置修饰符
  <<WindowsModifier,:topleft>>

| CTRL-W J
|
| 将当前窗口移动到底部，并且占用整个vim窗口的宽度。窗口的位置类似于位置修饰符
  <<WindowsModifier,:botright>>

| CTRL-W H
|
| 将当前窗口移动到最左面，占用整个vim窗口的高度。窗口的位置相当于
  <<WindowsModifier,:vert topleft split>>

| CTRL-W L
|
| 将当前窗口移动到最右面，占用整个vim窗口的高度。窗口的位置相当于
  <<WindowsMofifier,:vert botright split>>

| CTRL-W T
| *
| 将当前窗口移动到一个新的tab 页。
|===

// /* 窗口状态行 {{{4 */
==== 窗口状态行

使用 `laststatus` 选项可以设置什么时候最后的窗口存在状态行

[source, vim]
0       任何时候都没有
1       仅当存在分割窗口的时候，默认值
2       总是有

// /* Tab页 {{{3 */
[[TabPage]]
=== Tab 页
一个vim窗口的空间有限，不能分割太多窗口，或者分割的窗口空间很小，难于操作。为了
解决这个问题，vim支持tab页的概念。每个tab页具有vim的维度空间，每个tab可以分割
多个窗口。

[[TabOpen]]
==== Tab页打开文件
在启动vim时，可以使用 -p 选项，打开多个文件，每个文件使用不同的tab页。tab页的
数目由选项 `tabpagemax` 控制。

==== Tab页创建
下表列出关于tab页创建的命令。

[cols="2m,1,7a"]
|===
| 命令 | 计数 | 含义

| :tabe[dit] +
  :tabnew +
  :tabe[dit] _file_ +
  :tabnew _file_
| *
| 打开一个新的tab页。如果没有计数，新的tab页在当前页的后面。如果指定计数，新的
  tab也在计数指定的页后面。如果未指定文件新的tab页显示空，否者显示指定的文件。

[source,vim]
------
:tabnew     " opens tabpage after the current one
:.tabnew    " as above
:+tabnew    " opens tabpage after the next tab page
            " note: it is one further than :tabnew
:-tabnew    " opens tabpage before the current one
:0tabnew    " opens tabpage before the first one
:$tabnew    " opens tabpage after the last one
------
| :tabf[ind] _file_
| *
| 在<<Path,path>>列表查找 _file_ 文件，并将其现在在新的tab中。计数与上同。

| :tab {cmd}
| *
| 执行 {cmd}，如果命令打开一个新的窗口，使用新的tab页替代。计数与上同。

[source, vim]
------
:tab split      " opens current buffer in new tab page
:tab help gt    " opens tab page with help for gt
:.tab help gt   " as above
:+tab help      " opens tab page with help after the next tab page
:-tab help      " opens tab page with help before the current one
:0tab help      " opens tab page with help before the first one
:$tab help      " opens tab page with help after the last one
------

| kbd:[CTRL+W] kbd:[GF]
|
| 打开一个新的tab页，编辑当前光标指定的文件。

| kbd:[CTRL+W] kbd:[G] kbd:[Shift+F]
|
| 打开一个新的tab页，编辑当前光标指定的文件并跳转到文件名后面指定的行号。
|===

[[TabClose]]
==== Tab页关闭
关闭tab页的最后一个窗口，也关闭了这个tab页，除非这个tab是最后一个。也可以使用
鼠标点击tab页行的X来关闭tab页。

其它关闭tab页的命令如下：

[cols="2m,1,7a"]
|===
| 命令 | 计数 | 含义

| :tabc[lose][!]
| *
| 关闭当前tab页。如果仅有一个tab页或者未使用hidden，未使用!,当前buffer已经
  改变。如果指定了计数，关闭计数指定的tab页。例子如下

[source,vim]
------
:-tabclose      " close the previous tab page
:+tabclose      " close the next tab page
:1tabclose      " close the first tab page
:$tabclose      " close the last tab page
------

| :tabo[nly][!]
| *
| 关闭所有其它tab页。如果设置了选项 `hidden` ，被关闭窗口的所有buffer都成为了
  hidden。如果 `hidden` 没有被设置，但是设置了 `autowrite` 选项，被修改的
  buffer将被保存，否则包含被修改buffer的窗口不会被关闭，除非指定了!, 这时这些
  buffer成为hidden状态，但修改的buffer不会被删除，内容不会丢失。
  如果指定了计数，只保留计数指定的tab页，而不是当前tab页。例子如下：

[source,vim]
----
:tabonly        " close the current tab page
:.tabonly       " as above
:-tabonly       " close all tab pages except the previous one
:+tabonly       " close all tab pages except the next one
:1tabonly       " close all tab pages except the first one
:$tabonly       " close all tab pages except the last one
----

|===

[[TabSwitch]]
==== Tab页切换
使用鼠标，可以通过点击tab页行，切换tab页，下面介绍使用键盘切换tab页的命令。

[cols="2m,1,7a"]
|===
| 命令 | 计数 | 含义

| gt +
  :tabn[ext] +
  <C-PageDown>
| *
| 切换到下一个tab页，如果计数被指定，切换到计数指定的tab页。<C-PageDown>
  是CTRL-<PageDown>

| gT +
  :tabN[ext]
  :tabp[revious]
  <C-PageUp>
| *
| 切换到前一个tab页，如果计数被指定，切换到前面N个tab页，如果到达第一个，后续
  为最后一个。

| :tabr[ewind] +
  :tabfir[st]
|
| 切换到第一个tab页

| :tabl[ast]
|
| 切换到最后一个tab页
|===

[[TabMove]]
==== Tab页移动
下面的命令用于重新编排窗口顺序。

[cols="2m,1,9a"]
|===
| 命令 | 计数 | 含义

| :tabm[ove]
| *
| 如果未指定计数，将当前窗口移动到最后面。如果指定计数，将当前窗口移动到计数
  指定tab页的后面。计数为0，移动为第一个tab页。例子如下：

[source, vim]
------
:.tabmove   " do nothing
:-tabmove   " move the tab page to the left
:+tabmove   " move the tab page to the right
:0tabmove   " move the tab page to the beginning of the tab list
:tabmove 0  " as above
:tabmove    " move the tab page to the last
:$tabmove   " as above
:tabmove $  " as above
------

| :tabm[ove] +[N] +
  :tabm[ove] -[N]
|
| 将当前窗口向右（+）或者向左（-）移动N个位置，例子如下

[source,vim]
----
:tabmove -  " move the tab page to the left
:tabmove -1 " as above
:tabmove +  " move the tab page to the right
:tabmove +1 " as above
----
|===

[[TabStatus]]
==== Tab页状态

使用 `:tabs` 命令列出所有tab页以及tab页包含的窗口，其中以 `>` 修饰的为当前
窗口，以 `+` 修饰的为修改的buffer。 +
例如：

  Tab page 1
    + tabpage.txt
      ex_docmd.c
  Tab page 2
  >   main.c

[[TabBatch]]
==== Tab页批量执行
下面的命令用于批量执行某个命令。

[cols="2m,1,9a"]
|===
| 命令 | 计数 | 含义

| tabd[o] {cmd}
| *
| 在每个tab页执行{cmd}命令。如果提供[rang]，针对[rang]指定的tab页执行命令。

* 这个操作仅工作于每个tab页的当前窗口
* 当一个错误发生，后续tab页不再被访问
* 最后访问的tab页称为当前tab页
* {cmd} 可以包含‘\|’，串联几个命令
* {cmd} 禁止打开、关闭和重新排序tab页
|===


// /* 文件路径 {{{2 */ [[Path]]
== 文件路径

// /* 命令行 {{{2 */
[[CmdLine]]
== 命令行

[[CmdRange]]
=== 范围指定
一些命令可以在其前面指定行范围。这被称为range。它包含一个或者多个行标识，
行标识由逗号（，）或者分号（；）分隔。

如果使用分号（；）分隔，在解释下一个行标识之前，会将光标位置指定为当前行标识
的位置。如

[source, vim]
4,/这行/       "从当前行开始，直到搜索到第4行后匹配“这行”的行
5;/这行/       "将当前光标设置为第5行，然后从第5行搜索匹配“这行”的行

大多数命令的默认行标识符是光标所在的行。而“:write”和“:global”默认的行标识符是
整个文件，即(1,$)。

如果行标识符的数目大于命令要求的数目，前面的将被忽略。

==== 行标识符
行标识符可以使用下面的格式

[cols="1m,5"]
|===
| 行标识符 | 含义

| {number}  | 明确指定行号
| $         | 最后一行
| %         | 整个文件，相当于 1,$
| 't        | 记号t的位置
| 'T        | 记号T的位置，当这个记号在另一个文件时，不能在range中使用
| /{pattern}[/] | 下一个匹配{pattern}的行
| ?{pattern}[?] | 上一个匹配{pattern}的行
| \/            | 下一个匹配前面所使用{pattern}的行
| \?            | 上一个匹配前面所使用{pattern}的行
| \&            | 下一个匹配前面替代{pattern}的行
|===

// /* 查找 {{{2 */
[[search]]
== 查找

[[searchChar]]
=== 基于字符
[cols="2m,1,10"]
|===
| 命令 | 计数 | 简介

| f{char} | *
| 向右查找字符{char}的第N次出现
| F{char} | *
| 向左查找字符{char}的第N次出现

| t{char} | *
| 向右查找字符{char}的第N次出现,光标放在匹配字符之前
| T{char} | *
| 向左查找字符{char}的第N次出现,光标放在匹配字符之后

| ; | *
| 重复最后的 “f”，“F”，“t”，“T” 命令N次
| , | *
| 以相反的方向重复最后的 “f”，“F”，“t”，“T” 命令N次
|===

// /* 语法高亮 {{{2 */
[highlight]
== 语法高亮

=== 打开/关闭语法高亮
下面的命令可以使Vim根据不同文件类型进行语法高亮的显示：

[source,vim]
----
:syntax enable
----

=== 前置条件
如果你没有看到使用不同颜色高亮显示文本，可能存在如下原因：

- 终端不支持颜色 +
  Vim 支持使用粗体、斜体和下划线渲染正文，但是这个方式不是很好。最好选择支持
  颜色的终端。在Linux下，可以使用 `gnome-terminal` 或者x-term
- 终端支持颜色，但是Vim无法获知这个信息 +
  确保 $TERM 设置正确。查看这个环境变量的值，确保其支持颜色。通常如果其支持颜色
  其值应该是xterm-[num]color。
- 文件类型无法识别 +
  通常，Vim会根据文件的扩展名识别文件类型。请参考<<FileType,文件类型>>章节了解
  设置Vim检测文件类型的方式。如果文件不是使用标准的或者Vim可识别的扩展名，
  可以使用如下命令知道Vim正在编辑什么类型文件。 +
  `:set filetype` +
  如果结果是 `filetype=` ,那么说明Vim无法识别当前缓冲区的文件。可以实现如下的命
  另明确告诉Vim正在编辑什么类型的文件： +
  `:set filetype=fortran` +
  要知道什么类型的文件支持语法高亮，查看$VIMRUNTIME/syntax目录下的文件。另外在
  文件的开始或者结束位置中包含如下的注释行，Vim在每次读入这个文件时，它将自动
  语法高亮显示该文本。 如，对于makefile文件，使用 +
  `# vim: syntax=make`
- 指定的文件类型不支持语法高亮 +
  在这种情况下，可以使用Vim支持的相近语法的文件类型，或者自己动手写一个这用文件
  类型的语法高亮文件。  
- 设定的颜色很难阅读 +
  Vim会预判当前编辑窗口的背景色，并将文本的颜色设置成相反的色调。如果Vim判断错
  误，会导致文本难以阅读。在这种情况下可以明确设置 `background` 选项 +
  `:set background=dark` +
  `:set background=light`
  
=== 颜色主题
如果你不满意默认的颜色搭配，你可以使用其他颜色主题。可以使用下面的命令。如果
`colorscheme` 命令没有参数，则显示当前正在使用的schema。

  :colorscheme evening

evening是颜色主题的名称。所以预配置的颜色主题存放目录 `$VIMRUNTIME/colors` 。
在Vim可以使用下面的命令查看，正如你猜测到的，Vim知道 `$VIMRUNTIME` 的值。

  !ls $VIMRUNTIME/colors

我们可以定义自己的颜色主题，通常的做法如下：

. 从已有的主题中选择与希望比较相近的主题, 拷贝到自己的Vim目录。对于Linux，可以
  采用如下的操作
+
----
!mkdir ~/.vim/colors
!cp $VIMRUNTIME/colors/morning.vim ~/.vim/colors/mine.vim
----

. 编辑这个文件。特别是如下配置项
+
[frame=none, cols="1m,3"]
|===
| 配置项    | 含义

| term      | 黑白终端的属性
| cterm     | 彩色终端的属性
| ctermfg   | 彩色终端的前景色
| ctermbg   | 彩色终端的背景色
| gui       | 图形用户界面的属性
| guifg     | 图形用户界面的前景色
| guibg     | 图形用户界面的背景色
|===
例如，下面的命令设置注释使用绿色

 :highlight Comment ctermfg=green guifg=green
+
对于 `cterm` 和 `gui`，你可以设置它的属性为 `bold`，`underline` 或者 
`bold,underline`
. 使用下面的命令设置Vim使用自定义的颜色主题 +
  *colorscheme mine* +
  可以使用如下的命令显示各种颜色的搭配 +
  *：runtime syntax/colortest.vim*


// /* 文件类型（filetype） {{{2 */
[[FileType]]
== 文件类型（filetype）
Vim 可以根据文件的名称（主要是后缀）识别文件的类型。如果根据名称不能识别，Vim
也会试图根据文件的内容进行识别。依据不同的文件类型，你可以设置不同选项值，不用
的语法高亮，不同的键盘映射等等。

// /* 文件类型检测 {{{3 */
[[FileTypeDetect]]
=== 文件类型检测
想利用与文件类型相关的功能，首先需要让Vim检测到打开的文件属于什么类型。Vim 使
用如下的命令打开和关闭文件类型的检测功能。

[source,vim]
-----
    :filetype on
    :filetype off
-----

如果想获得与文件类型相关的帮助，可以使用如下的命令：

[source,vim]
------
    :help ft-vim-indent         "indent for specific file
    :help ft-vim-syntax         "syntax for specific file
    :help ft-man-plugin         "plugin for specific file
------

// /* 文件类型开关及其关系 {{{4 */
[[FileTypeSwitch]]
==== 文件类型开关及其关系
文件类型涉及到下面几个开关：检测开关，插件开关，缩进开关。下面分别介绍这些开关
的命令及其它们的关系。

[cols="1m,4a"]
|===
| 命令 | 说明

| :filetype on
| 打开文件检测开关。这个命令将会装入下面的文件之一，这个文件是Vim脚本文件，它
  定义了针对BufNewFile和BufRead事件的autocommands。 

------
    Amiga       $VIMRUNTIME/filetype.vim
    Mac         $VIMRUNTIME:filetype.vim
    MS-DOS      $VIMRUNTIME\filetype.vim
    RiscOS      Vim:Filetype
    Unix        $VIMRUNTIME/filetype.vim
    VMS         $VIMRUNTIME/filetype.vim
------

如果文件类型没能被这些为文件识别，Vim将会尝试使用 `$VIMRUNTIME/scripts` 从文
件的内容识别文件的类型。

你可以增加自己的文件类型，参见<<NewFileType,增加文件类型>>。

如果不能通过上面的方法自动检测，或者检测的类型不对。你可以使用下面两种方法手工
设置。

. 使用命令行命令
+
[source,vim]
------
:set filetype=vim
------
. 使用模式行。请参考<<modeline,模式行>>
+
[source,c]
------
/* vim: set filetype=idl : */
------

| :filetype plugin on
| 该命令装入特定文件类型的插件。如果执行该命令是文件类型检测的开关没有打开，
  Vim会自动打开文件检测开关。该命令实际上是装入 `runtimepath` 指定目录下的
  `ftplugin.vim` 文件，其结果是当一个文件被编辑时，如果存在与该文件对应的插件
  文件，那么与其对应的插件文件将被装入。

| :filetype plugin off
| 该命令关闭特定文件插件自动装入的功能。但是它并不自动关闭文件类型检测功能。该
  命令实际上装入 `runtimepath` 指定目录下的 `ftplugof.vim` 文件。

| :filetype indent on
| 该命令装入特定文件类型的缩进文件。该文件也会自动打开文件类型自动检测的开关。
  该命令实际上装入 `runtimepath` 目录下的 `indent.vim` 文件，其结果是当编辑一
  个文件时，如果如果存在与该文件类型对应的缩进文件，该缩进文件将会被装入。

| :filetype indent off
| 该命令关闭特定文件缩进文件自动装入的功能。但它并不自动关闭文件自动检测功能。
  该命令实际上装入 `runtimpath` 指定目录下的 `indoff.vim` 文件。该命令只影响将
  要打开的文件，不影响已经打开的文件。 如果想关闭一个打开文件的缩进功能，需要
  关闭选项 `autoindent`, `cindent`, `smartindent` and/or `indentexp`

| :filetype off
| 关闭文件类型自动检测功能。虽然插件和缩进的开关状态不变，但是因为文件类型不
  被检测，所以它们在再次打开文件检测开关前不会起作用。

| :filetype
| 显示文件类型自动检测、插件和缩进开关的状态
 
[source,vim]
------
:filetype
filetype detection:ON plugin:ON indent:OFF
------

| :filetype detect
| 如果你正编辑可以空文件，执行这个命令可以根据你敲入的内容尝试识别文件类型。比
  如你正在编写shell脚本，并且敲入了 `#!/bin/cash` 。该命令也自动打开检测开关。
  如同执行 `filetype on` 命令。
|===

下表总结了这个三种开关之间的关系：

[cols="2m,1m,1m,1m"]
|===
| 命令  | 类型检测 | 插件 | 缩进

|:filetype on           | on         | unchanged | unchanged
|:filetype off          | off        | unchanged | unchanged
|:filetype plugin on    | on         | on        | unchanged
|:filetype plugin off   | unchanged  | off       | unchanged
|:filetype indent on    | on         | unchanged | on
|:filetype indent off   | unchanged  | unchanged | on
|:filetype plugin indent on  | on        | on    | on
|:filetype plugin indent off | unchanged | off   | off
|===

NOTE: 文件类型也直接影响语法高亮，如果执行命令 `:syntax on` ，文件类型检测也会
自动打开。

// /* 增加文件类型 {{{4 */
[[NewFileType]]
==== 增加文件类型
如果你使用的文件类型没有被检测出来，存在如下四种方式增加你的文件类型。无论使用
何种方式，最好不要修改 `$VIMRUNTIME/filetype.vim` 文件。该文件在Vim升级是会自
动被覆盖。

a. 如果你想重定义所有默认文件类型检查。 +
   这种方法需要为没种文件都定义一个文件。其缺点不言而喻，会存在很多文件。其优
   点是你可以简单的将一个文件放到正确的目录使其工作。其步骤是：
   1. 创建用户级运行目录。通常是 `runtimepath` 定义的第一个目录。然后创建在其
      下面创建 `ftdetect` 目录。对于Unix，它是 `~/.vim/ftdetect`

// /* 多文件编辑 {{{2 */
== 多文件编辑
=== 编辑另一个文件
当编辑完一个文件后，可以不用退出vim，使用下面的命令编辑另一个文件

[source,vim]
:edit foo.txt

如果当前的文件没有保存，会弹出错误信息。可以使用``:edit! foo.txt`` 放弃当前修
改。或者使用``:hide edit foo.txt``隐含foo.txt到缓冲区，参见<<Buffer,缓冲区>>。
每条错误信息前面都会显示错误编号，可以使用``help``命令查看该错误编号的详细信息
。对于本例，``help E37``

----
E37: No write since last change (use ! to override)
----

=== 查看与切换

有如下涉及到多个文件编辑的命令

.多文件查看与切换命令
[cols="1m,2a"]
|====
| 格式 | 含义

| `vim` one.txt  two.txt  three.txt
| 同时编辑三个文件

| `:args` one.txt  two.txt  three.txt +
  `:args` \**/*.txt + 
  `:args` *.txt
| 在vim环境下，编辑三个文件 one.txt, tow.txt and three.txt,
  列出所有正在编辑的文件，用[]标注的是当前正在编辑的命令。
  args支持shell通配符。

| `:next` `:next!` +
  `:2next`  `:wnext` +
  `:previous` `:previous!` +
  `:wprevious`
| 切换到下一个或者上一个文件。如果当前文件没有保存会报错。如果有后缀!，
  放弃当前的修改。前面有字符w，表示先保存，在切换。如果前面有数字，
  相当于连续切换n次。

| CTRL-^
| 当编辑多个文件时，使用CTRL-^快捷键可以快速在最浏览的两个文件间切换。

| `"
| vim会记录每个文件编辑时所在的位置。当切换到某个文件时，使用该快捷键使光标
  跳转到你最后编辑这个文件时光标所在的位置。

| `.
| vim会记录每个文件最后修改的位置。当切换到某个文件时，使用该快捷键使光标切
  换到该文件最后修改的位置。

| 基于记号（mark）的切换
| 可以使用记号记录一个文件的某个位置，如果记号使用大写字母，这个记号将是全局
  的。可以在编辑一个文件时使用记号直接切换到另一个定义该记号的文件。例如，
  使用``mV``记录该文件的某个位置，然后切换到其它文件。然后使用```V``可以直接
  切换到该文件的那个位置。
|====

=== 备份
在默认情况下，vim不产生备份文件。如果希望产生备份文件，执行下面命令

  :set backup

备份文件的名称是在原文件名的后面加上一个波浪线符号（~）。如果想使用其它的扩展
名，使用如下的命令。 这样，文件data.txt的备份文件将是data.txt.bak，而不是
data.txt~。

  :set backupext=.bak


如果希望在编辑一个文件时保留一份修改前的备份，可以使用如下的命令。这样在一个
文件修改保存后，将会存在另一个扩展名为.orig的文件，这个文件是修改前的一个备份。

  :set patchmode=.orig


另外，不要忘记可以使用如下的命令设置自动保存或者关闭自动保存。

 :set [no]autowrite

=== 批量修改

. 进入vim
. :args \**/*
. :argdo %s/oldStr/newStr/egc \| update


// /* 记号 {{{2 */
[mark]
== 记号（mark）
记号是对文件中的一个位置的标识。通常由a-z小写字母对当前文件的位置做记号，
这类记号只在一个文件中有效，而用A-Z对某个文件的位置做全局的记号，这种记号也
称做文件记号，在不同文件间有效。

有如下关于记号的命令：

.主要记号命令
[cols="1m,3"]
|====
| 命令格式 | 说明

| m{a-zA-Z}
| 使用 `m` 快捷键为当前位置设置记号。记号使用小写或者大写字母进行标识

| m` or m'
| 使用符号`或者'设置当前位置，可以使用''或者``进行跳转

| m[ or m]
| 使用符号[或者]标识当前位置，可以使用'[或者']进行跳转

| '{a-z} `{a-z}
| 跳转到当前缓冲区文件的记号{a-z}

| '{A-Z0-9} `{A-Z0-9}
| 跳转到定义记号{A-Z}文件，并且跳转到记号{A-Z}

| g'{mark} g`{mark}
| 跳转到记号{mark}，但是不改变跳转列表（justlist），关于跳转列表参见<<jump,
  跳转列表>>

| :marks
| 列出所有记号，不包括记号 `(`, `)`, `{`, `}`

| :marks {arg}
| 列出指定的记号，如 `marks aB` 列出记号a和B

| :delm[arks] {marks}
| 删除指定的记号。不能删除记号'。记号可以使用枚举，用-分隔的区间，如果存在
  空格，空格将被忽略。如 +
  `:delmarks a` +
  `:delmarks a b 1` +
  `:delmarks ab1` +
  `:delmarks p-z` +
  `:delmarks ^.[]` +
  `:delmarks \"`  +

| :delm[arks]!
| 删除当前缓冲区中除了A-Z或者0-9以外的所有记号
|====

- a - z 小写字母记号只在定义它们的那个文件中有效，只要这个文件在缓冲区列表中
  存在，这些记号就会存在。如果这个文件从缓冲区列表中删除，那么这个文件定义的
  所有记号都会消失。如果删除了包含一个记号的行，那么这个记号也会被删除。

- 小写字母记号能够与操作符进行组合。比如 `d't` 将会删除当前光标所在行与记号 
  `t` 所标记的行之间的所有行。

- 大写字母记号记录了文件名，所以能够使用它们进行文件之间的跳转。当前正在显示
  的文件定义了某个大写字母记号，也可以在当前文件中进行记号与操作符组合。

- 记号标记的位置会根据插入或者删除行自动进行调整，从而保持是原来所标记的位置。

- 数字标记 `0-9` 是比较特殊的，它记录了退出文件时光标所在的位置。每次退出，
  新的光标位置使用0进行标记，上一次退出位置使用1进行标记，以此类推。

.其它记号命令
[cols="1m,3"]
|====
| 命令 | 说明

| '[  `[
|

| ']  `]
|

| '<  `<
|

| '>  `>
|

| ''  ``
|

| '"  `"
|

| '^  `^
|

| '.  `.
|

| '(  `(
|

| ')  `)
|

| '{  `{
|

| '}  `}
|

| ]'
|

| ]`
|

| ['
|

| [`
|

| :loc[kmarks] {command}
|

| :kee[pmarks] {command}
|

| :keepj[umps] {command}
|
|====

// /* 跳转列表 {{{2 */
[jump]
== 跳转列表 

// /* 缩展显示 {{{2 */
== 缩展显示（fold）
当一个文件的内容比较多时，很难看到这个文件的组织结构，vim提供了可嵌套fold机制。
通过这种机制，可以实现在一个页面内显示文件的结构，并可递进式显示文件的内容。

// /* fold概念  {{{3 */
=== fold概念
所谓fold是将多行正文显示成一行。fold的概念是基于window的，不会修改buffer的
内容，这意味着同一个文件在一个窗口可是使用fold，而在另一个窗口不使用。

当一个fold处于关闭状态时，vim的一些命令将其看作一行，如上下移动命令（j，k），
这允许快速掠过被fold的内容。这个特性也适合粘贴和删除操作。这对于程序代码的调整
是非常有用的。

// /* fold定义方法 {{{3 */
=== fold定义方法
vim提供了六种fold的方法，fold的定义方法通过选项 `foldmethod` 来指定：

manual::
    手工定义方法
indent::
    通过文件内容的缩进自动定义fold以及fold的层次。这种方法适合程序代码。
expr::
    通过表达式定义fold
syntax::
    通过语法高亮定义fold
diff::
    针对只读文件定义fold
marker::
    通过在文件中插入记号定义fold

// /* MARKER 方法 {{{3 */
=== MARKER 方法
Marker方法是在正文中标记fold的开始和结束。这允许你精确的指定fold，并且不会包括
错误的行。可以通过设置 `foldtext` 选项定义fold行的显示内容。默认情况下fold记号
前的内容会显示在folder行，通常会设置成标题。

// /* Marker 选项 {{{4 */
==== marker 选项
可以使用选项 `foldmarker` 定义fold的记号。它的默认值是 "{{{,}}}"。其中{{{标记
fold的开始，}}}标记fold的结束。

通常为了不影响文件的内容， `foldmarker` 定义在特定文件的注释行内。选项 
`commentstring` 定义了默认的注释行格式。默认值为 /*%s*/ 其中%s是包含了fold记号
的注释内容。

// /* Marker 范例 {{{4 */
==== marker 范例
可以只使用fold开始记号定义folder，记号后面加上大于0的数字表示级别。例如

[source, C+vim]
------
    /* global variables <<<1 */
    int varA, varB;

    /* functions <<<1 */
    /* funcA() <<<2 */
    void funcA() {}

    /* funcB() <<<2 */
    void funcB() {}
------

也可以明确使用结束标记指定fold的结束。另外，指定fold级别的标记和未指定fold
级别的标记可以混合使用。

[source,vim]
------
    <<<1
    fold level here is 1
    <<<3
    fold level here is 3
    >>>3
    fold level here is 2

    <<<
    fold level here is 1
    <<<
    fold level here is 2
    >>>
    fold level here is 1

------


上面的例子 `foldmarker` 定义为 “<<<,>>>”

// /* fold 命令 {{{3 */
=== fold 命令

// /* 创建和删除fold {{{4 */
==== 创建和删除fold

[cols="2m,1,7"]
|===
| 命令 | 计数 | 含义

| zf{motion} +
  {Visual}zf
|
| 创建fold。这个命令只有当 `foldmethod` 设置成 “mannual” 或者 “marker” 时才有
  效。对于 “mannual” 新的fold将会关闭， `foldenable` 被设置。

| zF
| *
| 创建一个包括计数指定行数的fold。其它类似zf

| :{range}fo[ld]
| *
| 创建一个{range}指定行数的fold。

| zd
|
| 删除一个光标所在的fold。当光标在fold行时，那个fold将被删除。嵌套的fold的级别
  将提升一级。没有undo操作，只针对mannual和marker。

| zD
|
| 递归删除光标所在的fold。只作用于mannual和marker。

| zE
|
| 删除fold的定义。只作用于mannual和marker
|===

// /* 打开和关闭fold {{{4 */
==== 打开和关闭fold

[cols="2m,1,7"]
|===
| 命令 | 计数 | 含义
| zo
| *
| 打开光标所在位置的1或者计数指定深度的fold

| zO
| 
| 递归打开所有光标所在位置的fold

| zc
| *
| 关闭1或者计数指定深度的fold

| zC
|
| 递归关闭所有fold

| za 
| *
| 当在关闭的fold时，打开它；当在打开的fold时，关闭它。计数可以指定打开或者
  关闭的深度

| zA
|
| 当在关闭的fold时，递归打开它；当在打开的fold时，递归关闭它。

| zv
|
| 打开必要的fold来显示当前光标所在的位置

| zx +
  zX
| 
| update folds. 当使用foldexpr时有帮助

| zm
| 
| fold more

| zM
|
| 关闭所有fold。设置foldlever为0

| zr
|
| 缩减fold层次

| zR
|
| 打开所有fold，设置foldlevel到最大的级别

|:{range}foldo[pen][!]
| *
| 但开{range}内的folds。如果使用!，{range}内的所有fold被打开，如果没有，打开
  一层

|:{range}foldc[lose][!]
| *
| 关闭{range}内的folds。如果使用!，{range}内的所有fold被关闭，如果没有，关闭
  一层

| zn
|
| 关闭 `foldenable` ，所有的folds被打开。

| zN
|
| 打开 `foldenable` ，所有的folds被关闭。

| zi
|
| 开关 `foldenable`
|===

// /* fold内/间移动 {{{4 */
==== fold内/间移动

[cols="2m,1,7"]
|===
| 命令 | 计数 | 含义

| [z
| *
| 移到当前打开fold的开始，如果已经在开始，移动包含该fold的fold的开始。
  如果存在计数，执行这个命令计数次。

| ]z
| *
| 移到当前打开fold的末尾，如果已经在末尾，移动包含该fold的fold的末尾。
  如果存在计数，执行这个命令计数次。

| zj
| *
| 移到下一个fold的开始， 如果存在计数，执行这个命令计数次。

| zk
| *
| 移到上一个fold的末尾， 如果存在计数，执行这个命令计数次。
|===

// /* 基于fold命令 {{{3 */
==== 基于fold命令

:[range]foldd[oopen] {cmd}::
    针对所有关闭fold外的行执行{cmd}。如果存在[range]，则仅针对指定范围的
    行。如下例所示，其中“e”是避免当没有匹配“end”时出现信息
+
[source,vim]
-------
:folddoopen s/end/loop_end/ge
-------

:[range]folddoc[losed] {cmd}::
    针对关闭fold中的所有行执行操作{cmd}。其它与前面的命令相同。

// /* fold选项 {{{3 */
=== fold选项
我们可以通过修改fold选项改变fold的显示风格和行为。fold具有如下的选项：

颜色::
    我们可以设置关闭的fold行的颜色。fold行颜色可以通过 `Folded` 组进行设置，
    fold列的颜色可以通过 `FoldColumn` 组进行设置。列子如下：
+
[source,vim]
------
:highlight Folded guibg=grey guifg=blue
:highlight FoldColumn guibg=darkgrey guifg=white
------

foldlevel::
    `foldlevel` 是个数字类型的选项，数值越大展开的区域越多。特别的
+
* 当它的值设置为0时，所有的fold都关闭；
* 当它的值大于当前定义最大的fold级别，所有的fold都展开；
* 当它的值大于0而小于当前定义的最大的fold级别，一部分fold将关闭；
* 如果它的值发生改变，它的新值立刻应用。fold按照新值进行打开和关闭；

foldtext::
    `foldtext` 是个string类型的选项，它定义了一个表达式，这个表达式用于定义
    关闭的fold行显示的内容，如
+
[source,vim]
------
:set foldtext=v:folddashes.substitute(getline(v:foldstart),'/\\*\\\|\\*/\\\|>>>\\d\\=','','g') <1>
------
<1> 显示fold定义的定义行，去掉“/*”，“*/”和“>>>”。
+
其默认是foldtext()函数。如果不满意，可以使用vim script表达式重现定义，可以使用
如下的vim变量, 如果结果存在Tab，使用空格代替，不可打印字符变成可打印字符。如果
太长将被裁剪适应窗口，如果存在多余的空间，使用 `fillchars` 替换。
+
[source, vim]
------
v:foldstart     " fold第一行的行数
v:foldend       " fold最后一行的行数
v:folddashes    " 包含表示fold级别的连字符的字符串
v:foldlevel     " fold的级别
------

foldcolumn::
    `foldcolumn` 是个数字类型的选项，定义了foldcolumn的宽度。foldcolum是用于
    显示fold层次和fold状态（open-或者close+）的区域。当它的值被设置成0时，
    没有foldcolumn，通常被设置成4或者5用于显示3或者4级深度的fold。
foldenable::
    当没有设置时，打开所有folds
foldexpr::
    定义fold的表达式
foldignore::
    用于缩进fold的字符
foldmarker::
    用于标记fold的标记
foldmethod::
    当前窗口进行fold的方法
foldminlines::
    一个fold块关闭时，fold行最小的屏幕行的数目
foldnestmax::
    fold最大的嵌套数
foldopen::
    什么命令可以打开关闭的fold
foldclose::
    如果被设置为all，当光标移动一个fold区域后，如果这个fold的级别大于 `foldlevel`
    这个fold将被关闭。当你希望离开一个fold时，相应的fold自动关闭，这个选项是有用
    的。 

// /* fold的行为 {{{3 */
=== fold的行为

* 当使用命令时，关闭的fold区域作为一个整体，作为一行处理。当光标处于关闭fold行，那么
  `dl` 命令将删除这个fold所包含的所有行。 `:s/foo/bar/g` 将会针对这个fold区域的所有行进
  行替换。
* 当编辑一个以前编辑过的buffer时，最后使用的fold设置被再次使用。手工定义的fold被恢复
  

// /* 格式化编辑 {{{2 */
== 格式化编辑

// /* 自动换行 {{{3 */
=== 自动硬换行
在默认情况下，vim不自动换行，你需要手工输入 Enter 键开始一个新行。这对于编程序
可能是有用的，由程序员决定换行的位置。然而对于普通的文档，通常每行的字数是固定
的，这样自动的换行是非常方便的。

使用选项textwidth设置一行可以包括多个字符，这里的字符数目是按照ascii字符数计数
的，对于中文一个字在unicode编排中使用两个字节。vim会使用选项breakat决定在那个
位置进行换行，这是因为对于英文一个字会包括多个Ascii字符，而按照习惯是不应该在
一个字中间进行换行的，这也会带来歧义。所以默认是在ascii的空格，标点符号位置进
行换行。但是对于中文明显不合适，中文的每个字符就是一个字，整个标准的中文段落是
看不到空格，ascii的标点符号的。注意中文的标点符号不在选项breakat的列表中。vim
考虑到这点，可以通过另外一个选项formatoptions定义中文字符也可以换行。另外通过
它也可以指定在粘接两行时不插入空格。

请参考 <<FormatOptions,formatoptions>> 详细了解它的定义。 当修改某个段落时vim
不自动重新格式化，请参考<<Reformat，重新格式化>>。

[source, vim]
------
:set textwidth=78       " 设置行的宽度为78个字符
:set fo=tcqmB           " fo 是 formatoptions的缩写
                        " m 指定遇到大于255的字符也进行换行
                        " B 指定合并两行时，两个多字节字符不插入空格
------

// /* 自动软换行 {{{3 */
=== 自动软换行
在很多情况下，我们不希望很长的段落插入硬换行，但是希望这个长行能够自动软换行，
以便每行的长度能够小于显示窗口的宽度。这样不需要水平滚动窗口就能看到一行所有的
内容。vim提供wrap选项开关控制软换行。

打开wrap开关，只是告诉vim当行超过窗口宽度时，自动软换行。对于英文这种字由多个
字符组成的语言，可能将一个字在行尾结成两部分处于不同的行，这很难阅读。vim提供
了linebreak开关选项，通过设定breakat选项，能够让一个字不被分割开。

[source, vim]
------
:set wrap       " 打开软换行
:set nowrap     " 关闭软换行
:set linebreak  " 打开linebreak
:set breakat    " 查看可以用于换行的字符
------

如果使用软换行，屏幕上显示的行数与真实的行数不一致，j k 命令是基于硬换行，vim
提供了 gj 和 gk 命令用于软换行，即屏幕上显示的行。可以使用键盘映射定义基于软换
行的上下移动键。

[source, vim]
------
:map <Up> gk
:map <Down> gj
------

// /* 缩进和Tab {{{3 */
=== 缩进和Tab
在编写代码时为了使代码易读，经常需要指定编码规则，其中的一条就是缩进规则。现在
的语言，比如Python甚至将缩进最为语法的一部分。本章介绍与缩进相关的选项和命令。

// /* 缩进选项 {{{4 */
==== 缩进选项

[cols="2m,8a"]
|===
| autoindent +
  ai
| 这是一个开关选项，默认关闭。当一个新行被插入时，新行自动获得与前面一行相同的
  缩进量，而不需要手工插入空格或者tab。

| shiftwidth
| 数值选项，默认8。它决定了缩进命令在进行一次缩进时缩进的宽度。

| expandtab + 
  et
| 开关选项。当打开是，使用空格替换tab。如果在其打开的情况下仍想插入tab，使用
  CTRL-V<Tab>。

| softtabstop +
  sts
| 数值选项。设置 swiftwidth 并不影响tab键的宽度。如果需要一个tab键具有
  swiftwidth 的宽度，需要设置 softtabstop 或者 tabstop 选项。softtabstop 与
  tabstop 不同之处在于，softtabstop会根据tabstop的设置混合插入tab字符和空格字
  符。

| tabstop +
  ts
| 数值选项。一个文件中一个<tab>字符等于多少个空格字符。设置tabstop除了8以外的
  值在很多场合会出现错误。比如打印。
+
存在四种方式设置tab的值:

. 总是设置tabstop为默认值8，设置 softtabstop 和 shiftwidth 为4（或者3或者其它
  值），使用 noexpandtab。那么vim将混合使用空格和tab字符，输入<Tab>或者<BS>时
  的行为就好像一个tab字符占用4个空格空间。
. 设置 tabstop 和 shiftwidth 为所希望的值，使用 expandtab。这种情况总是使用空
  格，文件的格式不会随着tabstop的改变而改变。
. 设置 tabstop 和 shiftwidth 为所希望的之，在编辑的文件中使用模式行设置这些
  值。当用vim打开这个文件中自动设置这些值。仅对vim有效。
. 总是设置 tabstop 和 shiftwidth相同的值，使用 noexpandtab。这对于任何不同的
  tabstop值显示均正确。
|===

// /* 缩进命令{{{4 */
==== 缩进命令

[cols="2m,1,7a"]
|===
| <{motion}
|
| 将{mothion}命令相关的行向左移动shiftwidth宽度,如 “<4j” 表示将当前行以下的4行
  向左移动1个shiftwidth宽度

| >{motion}
|
| 与 < 命令做相反方向的移动（向右）。

| <<
| *
| 将计数指定的行向左移动1个shiftwidth宽度

| {Visual}<
| *
| 将高亮显示的行向左移动计数指定个数的shiftwidth宽度。

| :[range]<
|
| 将[range]范围内的行向左移动1个“shiftwidth”宽度

| :[range]< {count}
|
| 将[range]开始的{count}行向左移动1个“shiftwidth”宽度

| >{motion}
|
| 与 < 命令做相反方向的移动（向右）。

| >>
| *
| 与 < 命令做相反方向的移动（向右）。

| {Visual}>
| *
| 与 < 命令做相反方向的移动（向右）。

| :[range]>
|
| 与 < 命令做相反方向的移动（向右）。

| :[range]> {count}
|
| 与 < 命令做相反方向的移动（向右）。
|===

如果希望一行几个 shiftwidth 宽度，使用 Visual 模式或者 `:` 命令。

[source, vim]
------
Vjj         " 将三行向右移动4个缩进宽度
:<<<        " 将当前行向左移动3个缩进宽度
:>> 5       " 将5行向右移动2个缩进宽度
:5>>        " 将第5行向右移动2个缩进宽度
------


// /* 选项formatoptions {{{3 */
[[FormatOptions]]
=== 选项formatoptions
选项 `formatoptions` 的缩写格式为 `fo` 。其值为一系列字母，每个字母称为令旗，
它们描述了怎么进行自动格式化，其默认值为 `tcq` 。令旗之间使用可选的逗号进行分
隔以增加可读性。当选项 `paste` 打开时，不进行任何格式化。可以使用 “+=” 或者 
“-=” 增加某个令旗。对于如何进行选项设置，请参见<<Option,选项>>。每个令旗的含义
见下表。

[cols="1m,9a"]
|====
| 令旗 | 含义

| t | 使用 `textwidth` 的设置，自动wrap过长的正文。

| c | 使用 `textwidth` 的设置自动wrap 注释行，并且自动插入注释的标识

| r | 在 `Insert` 模式，当输入 kbd:[Enter] 键时自动插入当前注释行的标识。

| o | 在 `Normal` 模式，当输入 `o` 或者 `O` 时，自动插入当前注释行的标识

| q 
| 允许使用 `gq` 命令格式化注释行。注意格式化不会改变空行或者仅包行注释标识的行
。

| w 
| 以空格结尾的行表示下一行和本行同属一个段落。一个以非空格字符结尾的行表示段落
  的结束。

| a
| 自动格式化段落。也就是说当增加或者删除一个段落的内容时，这个段落的内容将会重
  新格式化，详见<<AutoFormat,自动格式化>>。当与令旗 `c` 同时存在时，自动格式化
  只会影响可识别的注释行

| n
| 当格式化文本时，可以识别具有编号的列表。它使用 `formatlistpat` 选项来识别列
  表的格式。下一行将进行缩紧，正文与列表编号后的正文对其。默认的情况下编号是数
  字，数字后面也可以带有 '.', ':', ')', ']' 或者 '}' 。注意必须同时打开
  `autoindent` 。该令旗与令旗 `2` 同时使用时会有问题。
 
----
    1. the first item
       wraps
    2. the second item
----

| 2
| 使用段落的第二行的缩紧作为该段落其它行的缩紧，而不是使用第一行的缩紧。该令旗
  支持段落的第一行具有与其它行不同缩紧格式的情况。注意必须同时打开
  `autoindent` 。例如
 
----
        first line of a paragraph
    second line of the same paragraph
    third line
----

| v
| 在插入模式中使用Vi兼容的自动wrapping。 Only break a line at a blank that you
  have entered during the current insert command. (Note: this is not 100% Vi
  compatible. Vi has some "unexpected features" or bugs in this area. It uses
  the screen column instead of the line column.)

| b
| Like 'v', but only auto-wrap if you enter a blank at or before the wrap
  margin. If the line was longer than 'textwidth' when you started the insert,
  or you do not enter a blank in the insert before reaching 'textwidth', Vim
  does not perform auto-wrapping.

| l 
| 在插入模式中，对于长的行不进行分割换行。当开始插入模式时，如果一个行的宽度大
  于 `textwidth` 设置的值，Vim不对其进行格式化

| m 
| 也在超过255的多字节的字符处换行，这对于每个字符也是一个字的亚洲文本非常
  有用

| M 
| 当连接两个行时，在多字节字符前或者后不插入空格。如果与令旗B同时存在，令
  旗B将不起作用。

| B | 当连接两行时，在两个多字节字符间不插入空格。它与M同时存在时被忽略。

| 1 | 不在只包含一个字母的字后面换行，如果可能，在这个字的前面换行。
|====


// /* 重新格式化 {{{3 */
[[Reformat]]
=== 重新格式化

如果你修改了一段文本以后，Vim 不会自动重新格式化。比如，在默认情况下，虽然你设
置了行的宽度，但是当你在某行增加或者减少文字时，Vim不会将增加的文字换到下一行
，或者提升下一行的文字到本行。需要使用 `gq` 命令重新格式化。在本文的最后，将介
绍如何设置 Vim ，使其能够自动重新格式化。

// /* 重新格式化命令gq {{{4 */
==== 重新格式化命令gq

命令 `gq` 用于对一段文本进行格式化。因为 `gq` 是操作符，你可以使用下面三种方式
选择它作用的文本：Visual 模式，movement，和正文对象。

Visual 模式:: 
    假设存在一段五行的文本，当前光标处于第一行，则使用命令 `v4jgq` 重新对这段
    文本进行格式化。解释如下：
    `v` 开始进行Visual 模式， `4j` 向下跳4行，到达最后一行， `gq` 操作符进行文
    本的格式化工作。

movement::
    上面的列子，可以使用 `gq4j` 的方式完成。这种方式输入的次数比较少，但是你需
    要精确知道需要重新格式化的文本行数。
    一个更有用的动作命令是 `}` ，它能够移动到当前段落的末尾，所以命令 `gq}` 格
    式化光标所在的行到这个段落的末尾。对于上面的情况，它等同与前面两个命令。
    如果一个文件的所有段落都由空行很好的分隔（关于段落参见下节），你可以使用命
    令 `gggqG` 对整个文件进行格式化。其中 `gg` 是跳到第一行， `ggG` 是格式化直
    到最后一行。


文本对象::
    对于命令 `gq` ，一个非常有用的对象是段落。
    命令 `gqap` 将会格式化当前所在的段落。其中 `ap` 代表 `a paragraph` 。注意
    段落需要一个空行来标示。需要注意的包括空白字符（空格或者Tab）的行不是空行
    。

// /* 自动格式化 {{{4 */
[[AutoFormat]]
==== 自动格式化

通过在选项 <<FormatOptions,formatoptions>> 中增加令旗 `a` ，可以在增加或者删除字符时让 Vim 自
动进行格式化。 这对于格式化文本文件是非常有效的，下面给出几个提示：

* 合适地定义段落。最简单的做法是段落由一个空行分隔。如果不存在用于分隔段落的空
  行，考虑使用令旗 `w` 并且在一个段落除最后一行以外的所有行增加一个空格。

* 可以基于<<FileType,文件类型>> 或者某个文件的<<modeline,模式行>> 设置
  `formatoptions` ，使其更具有针对性。

* 设置 `formatoptions` 为 `aw2tq` 使得文本具有如下的缩进方式：
+
----
    bla bla foobar bla
bla foobar bla foobar bla
    bla bla foobar bla
bla foobar bla bla foobar
----

* 增加 `c` 令旗可以用于自动格式化注释（comment）。这对于源代码有作用。

* 设置 `textwidth` 可以定义每行最大的字符数。如果设置为0，使用79或者屏幕的宽度
  （当屏幕的宽度小于79）

[NOTE]
======
* 当文档的部分不是以段落进行划分的，对这部分进行修改将总是自动进行格式化，格式
  化的结果可能不是你所希望的，在这种情况下，考虑使用下面的命令禁止自动格式化。
+
[source,vim]
------
:set fo-=a
------

* 当使用 `w` （尾部的空格意味延续当前段落）令旗时，如果使用 `dd` 命令删除了段
  落的最后一行，后续的段落将合并到本段落。

* 为了进行撤销（undo）命令，对文本的修改将会被保存。格式化也是修改，因此每次的
  格式修改也会被保存，这将占用许多内存。

* 格式化一个长的段落，特别是定义了复杂的缩紧格式时速度可能会非常慢。
======

// /* 选项 {{{2 */
[[Option]]
== 选项（Option）

// /* 选项概念 {{{3 */
=== 选项概念
选项是vim的变量，通过这些变量用户可以改变或者扩展vim的行为。Vim有三种类型的变
量，它们的格式为：

[source, vim]
------
boolean         " 开关变量。可以打开或者关闭这些选项。
                " 对于某个开关选项，有两个选项名，如果选项名为name，
                " 则存在一个noname的选项名用于关闭这个开关，例如
                " set nu   用于显示行号 而
                " set nonu 用于取消显示行号
number          " 数值选项，其值为数。     <1>
string          " 字符串选项，其值为字符串 <1>
------
<1> 这种类型的选项通过 `:set optionName = optionValue` 的方式进行设置。

// /* 选项命令 {{{3 */
=== 选项命令

[cols="1m,3a"]
|===
| 命令 | 说明

| :se[t]
| 显示所有值不同于默认值的选项

| :se[t] all
| 显示除终端选项外的所有其它选项

| :se[t] termcap
| 显示所有终端选项

| :se[t] {option}?
| 显示 {option} 的值

| :se[t] {option}
| 
* boolean option: set (打开)
* number  option：显示它的值
* string  option：显示它的值

| :se[t] no{option}
| boolean option: reset （关闭）

| :se[t] {option}! +
  :se[t] inv{option}
| boolean option: 取当前{option}值的反

| :se[t] {option}&
| 重置其值为默认值

| :se[t] {option}&vi
| 重置其值为vi默认值

| :se[t] {option}&vim
| 重置其值为vim默认值

| :se[t] all&
| 重置除终端选项外的所有选项为其默认值。'term', 'lines' 和 'columns' 的值不变

| :se[t] {option}={value} +
  :se[t] {option}:{value}
| 对number，string类型的选项赋值。 +
  对于number类型选项，其值可以是十进制，十六进制（前面加上0x）或者八进制（前面
  加上0）。 +
  {option}和‘=’之间可以有空白字符，但是‘=’和{value}之间不允许有空白字符。如果
  字符类型选项值包括空格，需要使用反斜杠进行转义。

| :se[t] {option}+={value}
| 对于数值型选项，其值增加{value}；对于字符串类型选项填充{value}到原值后面。如
  果选项的值是逗号分隔的list，如果原值不为空，自动添加逗号。如果选项值是一系列
  flag，多余的将被移除，如果已经存在，选项值不变。

| :se[t] {option}^={value}
| 对于数值类型的选项，其值等于原来的值乘以{value}。对于string类型的选项，将
  {value}插到原值的前面。对于list类型，如果必要自动插入逗号。

| :se[t] {option}-={value}
| 对于数值类型的选项，其值减去{value}。对于string类型选项，其值如果存在
  {value}，删除它。如果不存在，不做任何事情。如果是list，删除不必要的逗号，如
  果是flag，精确匹配，最好一次删除一个。

|===

[NOTE]
======
* :set 命令可以同时设置多个选项，如果其中一个参数出错，会提示错误，后续选项设
  置被忽略。
+
[source,vim]
------
:set ai nosi sw=3 ts=3
------

* 如果选项 verbose 的值非0，显示一个选项的值也会给出这个值最后是在哪里设置的信
  息。可以使用:verbose命令执行下面的命令，而不需要提前设置 verbose 值。
+
[source,vim]
------
:set verbose=1 shiftwidth? foldmethod       "or
:verbose set shiftwidth? foldmethod         ":verbose 会设置 verbose 选项的值
  shiftwidth=4
        Last set from ~/.vimrc
  foldmethod=marker
        Last set from modeline
------

* 如果设置的选项值包括空格，反斜杠（\），竖线（|），双引号（"）等需要前面增加
  转义字符反斜杠。如
+
[source, vim]
------
:set titlestring=hi\ \"there\"     " result: hi "there"
:set dir=\\machine\path             " result: \\machine\path
                                    " 特例,适用于MS-DOS和WIN32环境
------

* string 类型的选项值可以包含环境变量，如果环境变量存在，$ 和它后面的环境变量
  将会被替换为环境变量的值，如果不存在，保持原值，不做替换。任何非标识符的字符
  （字母，数字，下划线）都可以跟在环境变量名后面作为分隔符，并且保留其值。
+
[source, vim]
------
:set term=$TERM.new
:set path=/usr/$INCLUDE,$HOME/include,.
------
======

// /* 选项作用域 {{{3 */
=== 选项作用域

// /* 自动设置选项 {{{3 */
[[AutoSetting]]
=== 自动选项设置
Vim 提供三种方式自动设置选项的值，而不用每次都在vim环境下使用 :set 命令进行设
置。

. 在启动Vim时，它的初始化过程会在很多地方读配置文件。大部分位置是用于所有对话
 （sessions），有些是依赖于Vim的启动目录。可以在任意配置文件或者初始化文件中设
  置选项的值。请参考<<Start,启动过程>>获知在什么地方使用什么文件。
. Autocommand 机制能够针对特定类型的文件在不同的事件下执行不同的命令，其中包括
  选项的设置，请参考<<Autocmd,AutoCmd>>获知详细的设置。
. 如果在编辑一个文件前，选项 modeline 打开，可以通过在这个文件的前面或者后面几
  行插入 modeline 来设置选项的值。在下面的<<modeline,模式行>>介绍这种方法。

// /* 模式行 {{{3 */
[[modeline]]
=== 模式行（modeline）
模式行是在编辑的文件的前面或者后面几行，插入一行Vim的set命令，从而在装入
这个文件时，Vim自动执行set命令，进行选项的设置。存在两种格式的模式行：

格式1: [text]{white}{vi:|vim:|ex:}{white}{options}::
+  
* [text]  +         
  任何正文或者空
* {white} +
  至少一个空白字符（空格或者tab）
* {vi:|vim:|ex:} +   
  开始进行设置
* {white}  +
  可选的空白字符
* {options} +
  选项设置。使用空白字符或者":"分隔选项
+
[source, vim]
------
vi:noai:sw=3 ts=6
------

格式2: [text]{white}{vi:|vim:|ex:}[white]se[t] {options}:[text]::
+
* [text]  +
  任何正文或者空
* {white} +
  至少一个空白字符（空格或者tab）
* {vi:|vim:|ex:} +
  开始进行设置
* {white}  +
  可选的空白字符
* se[t]    +
  字符串set或者se
* {options} +
  选项设置。使用空白字符分隔选项
* :  +   
  冒号
* [text]  +
  任何正文或者空
+
[source, vim]
------
 /* vim:net ai tw=78 sw=3: */
------

WARNING: 模式行起作用的前提条件是选项 modeline 打开




// /* Vim启动过程 {{{2 */
[[VimStart]]
== Vim启动过程

// /* Vim启动参数 {{{3 */
[[VimArguments]]
=== Vim启动参数

// /* Vim初始化 {{{3 */
[[VimInitialization]]
=== Vim初始化（Initialization）
在Vim启动时，Vim检查环境变量和文件并相应的进行各种设置。顺序如下：

1) 设置 `shell` 和 `term` 选项变量::
    如果环境变量 `SHELL` 存在，使用它的值设置选项 `shell`. 在MS-DOS，Win32环境
    下，如果 `SHELL` 不存在，使用 `COMSPEC` 。 +
    如果环境变量 `TERM` 存在，使用它的值设置选项 `term`. 不过当启动GUI时，
    `term` 的值会发生变化，参见后续的步骤8.
2) 处理参数::
    执行Vim命令时所带的参数，包括各种参数选项和参数文件被检测。为所有的参数文
    件穿件缓冲区（buffer）（但是没有装载文件）。参数 -V 可以被使用，用来显示或
    者记录启动过程发生的操作。这些信息有利于调试Vim的初始化过程。关于参数参见
    <<VimArguments,Vim启动参数>>。
3) 执行环境变量和／或文件中定义的Ex 命令::
    Vim识别某些环境变量，这些环境变量作为一个Ex命令行，如果存在多个命令，这些
    命令必须使用 ‘|’ 或者“<NL>“ 分隔开。
+
vim使用被称作”vimrc“的文件进行初始化，这个文件的每一行都作为一个Ex命令行执行。
有时候这个文件也可被命名为”exrc“。它们时相同类型的文件。exrc是vi使用的，”vimrc
“是vim特有的名字。
+
推荐将你的个人初始化命令放在如下的文件：
+
[cols="1m,3m",noframe]
|===
| Unix      | $HOME/.vimrc , $HOME/.vim/vimrc
| OS/2      | $HOME/.vimrc , $HOME/vimfiles/vimrc ,
              $VIM/.vimrc (or _vimrc)
| MS-DOS or
  Win32     | $HOME/_vimrc , $HOME/vimfiles/vimrc
              or $VIM/_vimrc
| Amiga     | s:.vimrc , home:.vimrc, home:vimfiles:vimrc or $VIM/.vimrc
|===
+
这个配置文件可以有不同的名字，放在不同的目录，Vim按照上表的顺序进行查找，只有
第一个匹配的被使。
+
[NOTE]
=====
* 如果Vim使用 `-u filename` 启动，这个 filename 文件被使用，所有下面的步骤直到步
  骤4都省略并且不设置内部环境变量 `$MYVIMRC` 。否则会设置成上表被查询到的那个
  文件目录。
* `vim -u NORC` 也会省略读一个文件进行初始化的步骤。 `vim -u NONE` 也略过装载插
  件（plugins）的步骤。 
* 如果Vim使用 “-s“ 参数启动，所有的后续步骤直到步骤4被略过。关于参数，参考
<<VimArguments,Vim启动参数>>。
=====
+
a. 如果 vim 作为 evim 或者 eview 或者使用参数 -y 启动，脚本文件
    *$VIMRUNTIME/evim.vim*  将会被装载。
b. *系统级vimrc文件* 被读进行初始化. +
   这个文件的位置可以使用 `:version` 命令获得。通常是 `$VIM/vimrc` 。这个文件
   在 ‘compatible’ 模式下总是被读的，因为在后续步骤中才会关闭这个选项。如果你
   愿意可以加 `:set nocp` 命令。 + 
   对于Macintosh, *$VIMRUNTIME/macmap.vim* 文件被读。 `VIM`, `VIMRUNTIME` 是内
   部环境变量，可以使用命令 `:echo $VIM` 获得它们的值。
c. *用户级别的初始化被检测和执行。* +
   Vim依次做如下方式的检测，如果一种方式成功，就不再做后续的检测。内部环境变量
   `MYVIMRC` 设置成第一个匹配的值。
   . 环境变量 *VIMINIT* 。它的值作为Ex命令行执行
   . *用户vimrc* 文件：

        "$HOME/.vimrc"          Unix and OS/2
        "$HOME/.vim/vimrc"      Unix and OS/2
        "s:.vimrc"              Amiga
        "home:.vimrc"           Amiga
        "home:vimfiles:vimrc"   Amiga
        "$VIM/.vimrc"           Amiga and OS/2
        "$HOME/vimfiles/vimrc"  MS-DOS and Win32
        "$HOME/_vimrc"          MS-DOS and Win32
        "$VIM/_vimrc"           MS-DOS and Wiin32
    
    . 环境变量 *EXINIT* 。它的值作为Ex命令行执行
    . 用户exrc 文件，与vimrc文件的作用相同，只是名字不同。
    . 默认的 `vimrc` 文件 `$VIMRUNTIME/defaults.vim` 。这个文件设置了某些选项
      的值，设置了 `syntax on` 和 `filetype on` 。这些设置多数新用户希望设置的
      。
d. 如果 `exrc` 选项打开（默认关闭），在当前目录搜索下面三个文件。最先搜索到的
   被执行，其它的忽略。使用这些文件将导致 `compatible` 选项关闭
   . `".vimrc" (Unix, Amiga and OS/2)` +
     `"_vimrc" (MS-DOS and Win32)`
   . `"_vimrc" (Unix, Amiga and OS/2)` +
     `".vimrc" (MS-DOS and Win32)`
   . `".exrc"  (Unix, Amiga and OS/2)` +
     `"_exrc"  (MS-DOS and Win32)`
4) 装载插件脚本（plugin）::
   做如下命令所做的事情： +
    `:runtime! plugin/\**/*.vim` +
    结果是选项 `runtimepath` 定义的所有的目录的 `plugin` 子目录被搜索，其下面
    包括其子目录下所有以 `.vim` 结尾的文件按照字母顺序被执行（sourced）。 +
    值得注意的是， `runtimepath` 中以 `after` 结尾的目录先被忽略。它们会在
    package 被装载后执行。 +
    Package被装载。这些包也是最为插件，但是它们搜索的是 `packpath` 定义的每项
    路径的 `start` 目录。这些目录下的每个 `plugin` 目录将被收集并加到
    `runtimepath` 选项中，然后这些插件目录下的脚本文件被执行（sourced）。 +
    然后， `runtimepath` 中以 `after` 结尾的目录下的插件脚本将被装载。 +
    在下面的情况下忽律该步骤的工作：
    * 选项 `loadpugins` 在某个 ·vimrc· 文件中被关闭
    * 使用了 `--noplugin` 命令行参数
    * 使用了 `-u NONE` 命令行参数
    * 当build Vim命令时没有配置 `+eval` 功能
    * 注意：使用 `-c 'set noloadplugins'` 不起作用，因为作为命令行参数，它在此
      时还没有执行。但是可以使用 `--cmd 'set noloadplugins` 参数。 
5) 设置 `shellpipe` 和 `shellredir` 选项::
    除非这两个选项已经被手工设置过，否则 `Vim` 会根据 `shell` 选项的值对这两个
    选项进行设置。
6) 如果使用了 `-n` 命令参数，设置 `updatecount` 选项的值为0::
7) 设置二进制相关的属性::
    如果在启动时使用了 `-b` 令旗（flag），与二进制编辑相关的选项将会被设置。关
    于该选项参见<<VimArguments,Vim启动参数>>
8) 执行 GUI 初始化::
    该步骤只在启动 `gvim` 的时候才起作用。参见<<GUI,GUI>>。
9) 读 `viminfo` 文件::
    如果 `viminfo` 选项非空，读 viminfo 文件。参见<<VimInfo, viminfo>>。
10) 读 quickfix 文件::
    如果使用了 `-q` 令旗，Vim读相应的 quickfix 文件。如果读失败，Vim退出。
11) 打开所有的窗口::
    如果使用 `-o` 令旗，窗口将被打开（但没有显示） +
    如果使用 `-p` 令旗，tab页将被创建（但没有显示） +
    如果使用 `-q` 令旗，跳到第一个错误 +
    所有窗口对应的缓冲区将被创建。
12) 执行启动（startup）命令::
    a. 如果使用 `-t` 令旗，跳转到相应的标签（tag）
    b. 使用 `-c` 或者 `+cmd` 参数指定的命令被执行
    c. 如果 `insertmode` 选项被打开，进入 `Insert` 模式
    d. staring 令旗被关闭
    e. `v:vim_did_enter` 变量设置成1
    f. `VimEnter` autocommand 被执行

// /* viminfo {{{3 */
[[VimInfo]]
=== viminfo

// /* Autocmd {{{2 */
[[Autocmd]]
== Autocmd

// /* 编程 {{{2 */
[[Programming]]
== 编程
Vim的主要目的是编写程序，特别是C语言程序，这章介绍Vim是如何支持编写代码的。

=== 编译（compile）
[[Compile]]
我们在编写程序后，还要进行编译，检查可能出现的语法错误，如果存在，更改再编译，
直到没有语法错误。

Vim提供了一些被称为 quickfix 命令，调用build工具保存错误输出并分析错误输出，自
动跳转到出错文件的出错行。该思想来源于Manx的运行在Amiga平台上的Aztec C编译器。

// /* make {{{3 */
[[Make]]
=== make

[[InteractiveWithShell]]
== 与Shell互动
在编辑文本的时候，你可以执行其它Unix命令。存在两种方式与其它命令的交互方式：在
线或者离线方式。

=== 离线方式（Suspend and Resume）
离线方式不是官方的叫法。这里所说的离线方式是指首先挂起vim进程，回到shell环境，
执行需要执行的命令，完成后在回到vim环境。

==== 挂起（suspend）
像大多数Unix程序一样，Vim程序可以通过 kbd:[CTL+Z] 被挂起。Vim被挂起后，系统将
工作的环境设成你执行Vim程序前的状态。在这个环境下，你可以执行任何其它的命令。

你也可以使用在Vim环境下使用 `:suspend` 命令挂起Vim

==== 恢复（resume）
当你执行完命令，或者想回到Vim的环境，你可以使用 `fg` 命令回到原来的Vim环境，这
个环境和挂起前没有任何改变，你可以无缝地继续原来的编辑工作。

NOTE: 不要忘记使用 `fg` 命令恢复Vim程序，否则你的任何没有保存的修改都将会丢失
。

=== 在线方式
如果仅想执行一个简单的shell命令，你可以使用 `:!{command}` 的在线方式。例如，如
果想知道当前目录下的文件列表，可以行用如下的方式：

    :!ls    'Linux 命令
    :!dir   'Windows 命令

有下面几种方式：

[cols="m,a"]
|======
| command | comments

| :!{program}
| 执行 {program}

| :r !{program}
| 执行 {program}，并将其结果插入到当前编辑的文件

| :w !{program}
| 执行 {program}, 并将当前编辑文本的内容作为 {program} 的输入

| :[range]!{program}
| 通过 {program} 过滤文本

|======

// /* GUI {{{2 */
[[GUI]]
== GUI

// /* 主要插件 {{{2 */
[[plugins]]
[bibliography]
== 主要插件
- [[[1]]] https://github.com/fatih/vim-go[Offical Go 插件]
- [[[2]]] https://github.com/nsf/gocode[Go Autocompletion]
- [[[3]]] https://https://github.com/junegunn/vim-plug/wiki/tutorial[Vim
  Plugin Manager]

// /* 参考文献 {{{2 */
[bibliography] 
== 参考文献

- [[[1]]] http://vimdoc.sourceforge.net/htmldoc/[Vim 参考手册]
- [[[2]]] http://www.yolinux.com/TUTORIALS/LinuxTutorialAdvanced_vi.html[ vi
  and vim editor: Tutorial and advance features]
- [[[3]]] https://vim.swaroopch.com/[A Byte of Vim]
- [[[4]]]
  https://www.ibm.com/developerworks/cn/linux/l-vim-script-1/index.html#authorN1001F[Vimscript
基本元素入门]

// vim: set syn=asciidoc fdm=marker fdl=1 tw=78 fo=tcqmB:
